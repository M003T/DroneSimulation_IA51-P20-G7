package io.sarl.airsim.behaviors.target

import fr.utbm.airsim.api.LidarData
import fr.utbm.airsim.api.Pose
import fr.utbm.airsim.api.Quaternionr
import io.sarl.airsim.influences.MoveByVelocity
import io.sarl.airsim.influences.RotateToYaw
import io.sarl.airsim.influences.Takeoff
import io.sarl.airsim.math.Vector3
import io.sarl.airsim.perceptions.LidarDataPerception
import io.sarl.airsim.perceptions.sim.SimGroundTruthKinematicsPerception
import io.sarl.airsim.perceptions.sim.SimPosePerception
import io.sarl.airsim.simulation.events.SimulationInitialized
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Logging
import io.sarl.core.Schedules

/** 
 * This is our own drone behavior which is supposed to enable them to set a target location to reach while avoiding obstacles and then return to the base
 * @author Malek Fardeau
 */

behavior ReachLocationWithObstacleAvoidance {
	
	uses Logging, DefaultContextInteractions, Schedules
	
	// Variables
	protected var position : Vector3 = null
	protected var orientation : Quaternionr = null
	protected var speed : Vector3 = null
	protected var targetlocation : Vector3 = null
	protected var lidarData : float[] = null
	var initialized = false
	val periodMs : int = 1000

	//For loop behavior when the simulation starts
	on SimulationInitialized {
		emit(new Takeoff) //Emit takeoff event to notify the SimulationControllerAgent
		
		initialized = true
		
		in(5000) [ // Initial delay before starting
			info("Je tourne")
			emit(new RotateToYaw(180f)) //Initial rotation to face the wall
			
			every(periodMs) [ //Period at which we reevaluate the drone actions
				val movementForce : Vector3 = computeForce() // Create a force vector for the movement
				
				emit(new MoveByVelocity(movementForce.getX(), movementForce.getY(), movementForce.getZ(), periodMs/1000f))
			]
		]
		
	}
	
	//Update SARL position and orientation when a PosePerception is received from Airsim
	on SimPosePerception {
		val positionPerceived : Pose = occurrence.pose //We retrieve the position perceived from Airsim
		this.position = new Vector3(positionPerceived.position)
		this.orientation = positionPerceived.orientation
	}

	//Update SARL velocity when a KinematicsPerception is received from Airsim
	on SimGroundTruthKinematicsPerception {
		val velocity : Vector3 = new Vector3(occurrence.state.linearVelocity)
		this.speed = velocity
	}

	// Update SARL LidarData when a LidarDataPerception is received from Airsim
	on LidarDataPerception {
		val lidarPointCloud : float[] = occurrence.lidarData.pointCloud
		this.lidarData = lidarPointCloud
	}

	//Function that computes the force the move the drone
	def computeForce() : Vector3 {
		var result : Vector3 = new Vector3
		val position : Vector3 = new Vector3(this.position)
		val lidarPointCloud : float[] = this.lidarData
		
		info("Ma position : " + position.x + ", " + position.y + ", " + position.z)
		if (position.z > -2 || lidarPointCloud.size < 3) {
			info("J'avance")
			result = new Vector3(20f, 0f, -10f) // Create a force vector for the movement
		}
		else {
			info("J'ai un obstacle à éviter : " + lidarPointCloud.get(0) + ", " + lidarPointCloud.get(1) + ", " + lidarPointCloud.get(2))
			
			val pointToAvoid : Vector3 = new Vector3(lidarPointCloud.get(0), lidarPointCloud.get(1),lidarPointCloud.get(2))
			var distance : Vector3 = new Vector3()
			distance = pointToAvoid-position
			result = new Vector3(-5*distance.x, -5*distance.y, -10f)
			this.lidarData = null //To not recompute old LidarData
			info("J'evite l'obstacle avec une force : " + result.x + ", " + result.y + ", " + result.z)
		}
		return result
	}
}