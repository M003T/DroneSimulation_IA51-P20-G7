package io.sarl.airsim.behaviors.target

import fr.utbm.airsim.api.LidarData
import fr.utbm.airsim.api.Pose
import fr.utbm.airsim.api.Quaternionr
import io.sarl.airsim.influences.MoveByVelocity
import io.sarl.airsim.influences.RotateToYaw
import io.sarl.airsim.influences.Takeoff
import io.sarl.airsim.math.Vector3
import io.sarl.airsim.perceptions.LidarDataPerception
import io.sarl.airsim.perceptions.sim.SimGroundTruthKinematicsPerception
import io.sarl.airsim.perceptions.sim.SimPosePerception
import io.sarl.airsim.simulation.events.SimulationInitialized
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Logging
import io.sarl.core.Schedules

/** 
 * This is our own drone behavior which is supposed to enable them to set a target location to reach while avoiding obstacles and then return to the base
 * @author Malek Fardeau
 */

behavior ReachLocationWithObstacleAvoidance {
	
	uses Logging, DefaultContextInteractions, Schedules
	
	// Variables
	protected var position : Vector3 = null
	protected var orientation : Quaternionr = null
	protected var speed : Vector3 = null
	protected var targetlocation : Vector3 = null
	protected var lidarData : LidarData = null
	var initialized = false

	//For loop behavior when the simulation starts
	on SimulationInitialized {
		emit(new Takeoff) //Emit takeoff event to notify the SimulationControllerAgent
		
		initialized = true
		
		in(5000) [ // Initial delay before starting
			emit(new RotateToYaw(180f)) //Initial rotation to face the wall
			
			every(1000) [ //Period at which we reevaluate the drone actions
				val movementForce : Vector3 = computeForce() // Create a force vector for the movement
				
				emit(new MoveByVelocity(movementForce.getX(), movementForce.getY(), movementForce.getZ(), 1f))
			]
		]
		
	}
	
	//Update SARL position and orientation when a PosePerception is received from Airsim
	on SimPosePerception {
		val positionPerceived : Pose = occurrence.pose //We retrieve the position perceived from Airsim
		this.position = new Vector3(positionPerceived.position)
		this.orientation = positionPerceived.orientation
	}

	//Update SARL velocity when a KinematicsPerception is received from Airsim
	on SimGroundTruthKinematicsPerception {
		val velocity : Vector3 = new Vector3(occurrence.state.linearVelocity)
		this.speed = velocity
	}

	// Update SARL LidarData when a LidarDataPerception is received from Airsim
	on LidarDataPerception {
		this.lidarData = occurrence.lidarData
	}

	//Function that computes the force the move the drone
	def computeForce() : Vector3 {
		var result : Vector3 = new Vector3
		info("Ma position :" + this.position.x + ", " + this.position.y + ", " + this.position.z)
		if (this.position.z < 0 || lidarData.pointCloud.size < 3) {
			info("J'avance")
			result = new Vector3(20f, 0f, -10f) 		// Create a force vector for the movement
		}
		else {
			info("J'ai un obstacle à éviter")
			var pointToAvoid : Vector3 = new Vector3(lidarData.pointCloud.get(0), lidarData.pointCloud.get(1),lidarData.pointCloud.get(2))
			var distance : Vector3 = new Vector3()
			distance = pointToAvoid-this.position
			result = new Vector3(distance.x, distance.y, -10f)
		}
		return result
	}
}